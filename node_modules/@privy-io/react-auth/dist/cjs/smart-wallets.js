"use strict";var e=require("react/jsx-runtime"),t=require("react"),r=require("./useWallets.js"),a=require("./privy-context.js"),n=require("./getEmbeddedConnectedWallet.js"),i=require("permissionless"),s=require("permissionless/accounts"),l=require("permissionless/clients/pimlico"),o=require("viem"),c=require("viem/account-abstraction");require("tinycolor2"),require("ofetch");let d=({calls:e,chain:t,maxPriorityFeePerGas:r,maxFeePerGas:a,nonce:n})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:n,maxFeePerGas:a,maxPriorityFeePerGas:r})));let u={address:c.entryPoint06Address,version:"0.6"},m={address:c.entryPoint07Address,version:"0.7"},y=["rpc.zerodev.app","public.pimlico.io","api.pimlico.io"],p=async({owner:e,smartWalletType:t,chain:r,bundlerUrl:a,paymasterUrl:n,paymasterContext:c})=>{let d=o.createPublicClient({chain:r,transport:o.http()}),p=await(({owner:e,smartWalletType:t,chain:r})=>{let a=o.createPublicClient({chain:r,transport:o.http()});switch(t){case"safe":return s.toSafeSmartAccount({client:a,entryPoint:m,owners:[e],version:"1.4.1"});case"kernel":return s.toEcdsaKernelSmartAccount({client:a,version:"0.3.1",entryPoint:m,owners:[e]});case"biconomy":return s.toBiconomySmartAccount({client:a,owners:[e],entryPoint:u});case"light_account":return s.toLightSmartAccount({client:a,entryPoint:u,owner:e,version:"1.1.0"});default:throw Error(`Invalid smart account type: ${t}.`)}})({owner:e,smartWalletType:t,chain:r}),g=l.createPimlicoClient({transport:o.http(a),entryPoint:p.entryPoint}),P=n?l.createPimlicoClient({transport:o.http(n),entryPoint:p.entryPoint}):void 0;return i.createSmartAccountClient({account:p,chain:r,paymaster:P,paymasterContext:c,bundlerTransport:o.http(a),userOperation:{estimateFeesPerGas:async()=>{if(y.some((e=>a.includes(e))))return await g.getUserOperationGasPrice().then((e=>e.fast));{let e=await d.estimateFeesPerGas();return{...e,maxFeePerGas:125n*e.maxFeePerGas/100n,maxPriorityFeePerGas:125n*e.maxPriorityFeePerGas/100n}}}}})};let g=t.createContext({client:void 0});let P=t.createContext({config:void 0}),h=()=>{let{config:e}=t.useContext(P);return{config:e}},E=({children:r})=>{let[n,i]=t.useState(void 0),{client:s}=a.usePrivyInternal();return t.useEffect((()=>{!n&&s&&(async()=>{try{if(!s)return void console.warn("No client found");let e=await s.getSmartWalletsConfig();i(e)}catch(e){console.warn("Error generating smart wallet config: ",e)}})()}),[!!s]),e.jsx(P.Provider,{value:{config:n},children:r})},v=({config:i,children:s})=>{let{config:l}=h(),{defaultChain:o}=r.useAppConfig(),[c]=t.useState(o),{wallets:d}=r.useWallets(),{user:u}=a.usePrivy(),[m,y]=t.useState(),g=n.getEmbeddedConnectedWallet(d);return t.useEffect((()=>{(async()=>{if(!l?.enabled||!u||!g)return void y(void 0);if(m&&m.chain.id===c.id)return;let e=l.configuredNetworks.find((e=>e.chainId===`eip155:${c.id}`));if(!e)throw new a.PrivyClientError(`The chain ${c.name} (eip155:${c.id}) must be configured in the smart wallet configuration in your dashboard`);let t=u.smartWallet?.smartWalletType??l.smartWalletType;try{let r=await(async(e,t,r,a,n)=>{let i=await e.getEthereumProvider();return await p({owner:i,smartWalletType:r,chain:t,paymasterContext:n,...a})})(g,c,t,e,i?.paymasterContext);y(r)}catch(e){console.error("Error loading smart wallet:",e)}})()}),[!!l?.enabled,!!u?.smartWallet,!!g]),e.jsx(f.Provider,{value:{client:m},children:s})},f=t.createContext({client:void 0}),W=({children:i})=>{let{client:s}=(()=>{let{client:e}=t.useContext(f);return{client:e}})(),{config:l}=h(),{wrapSmartAccountClient:o}=(()=>{let{noPromptOnSignature:e,openPrivyModal:t}=a.usePrivyInternal(),i=r.useAppConfig(),{setModalData:s}=n.usePrivyModal();return{wrapSmartAccountClient:r=>{let{sendTransaction:a,signMessage:l,signTypedData:o,...c}=r;return{...c,sendTransaction:async r=>{if(void 0===i.embeddedWallets.showWalletUIs?i.embeddedWallets.noPromptOnSignature:!i.embeddedWallets.showWalletUIs)return e.current=!0,await a(r).finally((()=>e.current=!1));let l=[];"calls"in r&&void 0!==r.calls?l=[...r.calls]:"to"in r&&(l=[{to:r.to,value:r.value||BigInt(0),data:r.data||"0x"}]);let o=async()=>{if(!c.paymaster)return!1;let{paymasterAndData:e,paymasterData:t}=await c.prepareUserOperation({calls:l,maxFeePerGas:r.maxFeePerGas,maxPriorityFeePerGas:r.maxPriorityFeePerGas,nonce:r.nonce?BigInt(r.nonce):void 0});return Number(e??t??0)>0};return new Promise((async(i,u)=>{e.current=!0,s({connectWallet:{onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:d({calls:l,chain:c.chain,maxPriorityFeePerGas:r.maxPriorityFeePerGas,maxFeePerGas:r.maxFeePerGas,nonce:r.nonce?BigInt(r.nonce):void 0}),rootWallet:{address:c.account.address},transactingWallet:{address:c.account.address,walletIndex:null},getIsSponsored:o,onConfirm:()=>a(r),onSuccess:e=>i(e.hash),onFailure:u,uiOptions:{}}}),t(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))},signMessage:async({message:r})=>(void 0===i.embeddedWallets.showWalletUIs?i.embeddedWallets.noPromptOnSignature:!i.embeddedWallets.showWalletUIs)?(e.current=!0,await l({message:r}).finally((()=>e.current=!1))):new Promise((async(a,i)=>{e.current=!0,s({connectWallet:{onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:r,confirmAndSign:()=>l({message:r}),onSuccess:e=>a(e),onFailure:i,uiOptions:{}}}),t(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})),signTypedData:async r=>(void 0===i.embeddedWallets.showWalletUIs?i.embeddedWallets.noPromptOnSignature:!i.embeddedWallets.showWalletUIs)?(e.current=!0,await o(r).finally((()=>e.current=!1))):new Promise((async(a,i)=>{e.current=!0,s({connectWallet:{onCompleteNavigateTo:n.ModalScreen.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:r,confirmAndSign:()=>o(r),onSuccess:e=>a(e),onFailure:i,uiOptions:{}}}),t(n.ModalScreen.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))}}}})(),{user:c}=a.usePrivy(),{generateSiweMessageForSmartWallet:u,linkSmartWallet:m,noPromptOnSignature:y}=a.usePrivyInternal();return t.useEffect((()=>{(async()=>{if(s&&!c?.smartWallet&&l?.enabled)try{let e=await u({address:s.account.address,chainId:`eip155:${s.chain.id}`});y.current=!0;let t=await s.signMessage({message:e});await m({signature:t,message:e,smartWalletType:l.smartWalletType})}catch(e){console.error("Error creating smart wallet:",e)}finally{y.current=!1}})()}),[!!s,!!c?.smartWallet,!!l?.enabled]),e.jsx(g.Provider,{value:{client:c?.smartWallet&&s?o(s):void 0},children:i})};exports.SmartWalletsProvider=({config:t,children:r})=>e.jsx(E,{children:e.jsx(v,{config:t,children:e.jsx(W,{children:r})})}),exports.useSmartWallets=()=>{let{client:e}=t.useContext(g);return{client:e}};
