import{jsx as e}from"react/jsx-runtime";import{useContext as t,useState as a,useEffect as r,createContext as n}from"react";import{u as i,J as s}from"./useWallets.mjs";import{u as o,h as l,P as c}from"./privy-context.mjs";import{u as d,M as m,g as u}from"./getEmbeddedConnectedWallet.mjs";import{createSmartAccountClient as p}from"permissionless";import{toLightSmartAccount as y,toBiconomySmartAccount as g,toEcdsaKernelSmartAccount as h,toSafeSmartAccount as E}from"permissionless/accounts";import{createPimlicoClient as f}from"permissionless/clients/pimlico";import{createPublicClient as P,http as w}from"viem";import{entryPoint06Address as W,entryPoint07Address as v}from"viem/account-abstraction";import"tinycolor2";import"ofetch";let T=({calls:e,chain:t,maxPriorityFeePerGas:a,maxFeePerGas:r,nonce:n})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:n,maxFeePerGas:r,maxPriorityFeePerGas:a})));let S={address:W,version:"0.6"},C={address:v,version:"0.7"},N=["rpc.zerodev.app","public.pimlico.io","api.pimlico.io"],x=async({owner:e,smartWalletType:t,chain:a,bundlerUrl:r,paymasterUrl:n,paymasterContext:i})=>{let s=P({chain:a,transport:w()}),o=await(({owner:e,smartWalletType:t,chain:a})=>{let r=P({chain:a,transport:w()});switch(t){case"safe":return E({client:r,entryPoint:C,owners:[e],version:"1.4.1"});case"kernel":return h({client:r,version:"0.3.1",entryPoint:C,owners:[e]});case"biconomy":return g({client:r,owners:[e],entryPoint:S});case"light_account":return y({client:r,entryPoint:S,owner:e,version:"1.1.0"});default:throw Error(`Invalid smart account type: ${t}.`)}})({owner:e,smartWalletType:t,chain:a}),l=f({transport:w(r),entryPoint:o.entryPoint}),c=n?f({transport:w(n),entryPoint:o.entryPoint}):void 0;return p({account:o,chain:a,paymaster:c,paymasterContext:i,bundlerTransport:w(r),userOperation:{estimateFeesPerGas:async()=>{if(N.some((e=>r.includes(e))))return await l.getUserOperationGasPrice().then((e=>e.fast));{let e=await s.estimateFeesPerGas();return{...e,maxFeePerGas:125n*e.maxFeePerGas/100n,maxPriorityFeePerGas:125n*e.maxPriorityFeePerGas/100n}}}}})};let D=n({client:void 0});const F=({config:t,children:a})=>e(I,{children:e(M,{config:t,children:e(A,{children:a})})}),_=()=>{let{client:e}=t(D);return{client:e}};let G=n({config:void 0}),b=()=>{let{config:e}=t(G);return{config:e}},I=({children:t})=>{let[n,i]=a(void 0),{client:s}=o();return r((()=>{!n&&s&&(async()=>{try{if(!s)return void console.warn("No client found");let e=await s.getSmartWalletsConfig();i(e)}catch(e){console.warn("Error generating smart wallet config: ",e)}})()}),[!!s]),e(G.Provider,{value:{config:n},children:t})},M=({config:t,children:n})=>{let{config:o}=b(),{defaultChain:d}=i(),[m]=a(d),{wallets:p}=s(),{user:y}=l(),[g,h]=a(),E=u(p);return r((()=>{(async()=>{if(!o?.enabled||!y||!E)return void h(void 0);if(g&&g.chain.id===m.id)return;let e=o.configuredNetworks.find((e=>e.chainId===`eip155:${m.id}`));if(!e)throw new c(`The chain ${m.name} (eip155:${m.id}) must be configured in the smart wallet configuration in your dashboard`);let a=y.smartWallet?.smartWalletType??o.smartWalletType;try{let r=await(async(e,t,a,r,n)=>{let i=await e.getEthereumProvider();return await x({owner:i,smartWalletType:a,chain:t,paymasterContext:n,...r})})(E,m,a,e,t?.paymasterContext);h(r)}catch(e){console.error("Error loading smart wallet:",e)}})()}),[!!o?.enabled,!!y?.smartWallet,!!E]),e(O.Provider,{value:{client:g},children:n})},O=n({client:void 0}),A=({children:a})=>{let{client:n}=(()=>{let{client:e}=t(O);return{client:e}})(),{config:s}=b(),{wrapSmartAccountClient:c}=(()=>{let{noPromptOnSignature:e,openPrivyModal:t}=o(),a=i(),{setModalData:r}=d();return{wrapSmartAccountClient:n=>{let{sendTransaction:i,signMessage:s,signTypedData:o,...l}=n;return{...l,sendTransaction:async n=>{if(void 0===a.embeddedWallets.showWalletUIs?a.embeddedWallets.noPromptOnSignature:!a.embeddedWallets.showWalletUIs)return e.current=!0,await i(n).finally((()=>e.current=!1));let s=[];"calls"in n&&void 0!==n.calls?s=[...n.calls]:"to"in n&&(s=[{to:n.to,value:n.value||BigInt(0),data:n.data||"0x"}]);let o=async()=>{if(!l.paymaster)return!1;let{paymasterAndData:e,paymasterData:t}=await l.prepareUserOperation({calls:s,maxFeePerGas:n.maxFeePerGas,maxPriorityFeePerGas:n.maxPriorityFeePerGas,nonce:n.nonce?BigInt(n.nonce):void 0});return Number(e??t??0)>0};return new Promise((async(a,c)=>{e.current=!0,r({connectWallet:{onCompleteNavigateTo:m.EMBEDDED_WALLET_SEND_TRANSACTION_SCREEN,onFailure:()=>{}},sendTransaction:{transactionRequests:T({calls:s,chain:l.chain,maxPriorityFeePerGas:n.maxPriorityFeePerGas,maxFeePerGas:n.maxFeePerGas,nonce:n.nonce?BigInt(n.nonce):void 0}),rootWallet:{address:l.account.address},transactingWallet:{address:l.account.address,walletIndex:null},getIsSponsored:o,onConfirm:()=>i(n),onSuccess:e=>a(e.hash),onFailure:c,uiOptions:{}}}),t(m.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))},signMessage:async({message:n})=>(void 0===a.embeddedWallets.showWalletUIs?a.embeddedWallets.noPromptOnSignature:!a.embeddedWallets.showWalletUIs)?(e.current=!0,await s({message:n}).finally((()=>e.current=!1))):new Promise((async(a,i)=>{e.current=!0,r({connectWallet:{onCompleteNavigateTo:m.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"personal_sign",data:n,confirmAndSign:()=>s({message:n}),onSuccess:e=>a(e),onFailure:i,uiOptions:{}}}),t(m.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1})),signTypedData:async n=>(void 0===a.embeddedWallets.showWalletUIs?a.embeddedWallets.noPromptOnSignature:!a.embeddedWallets.showWalletUIs)?(e.current=!0,await o(n).finally((()=>e.current=!1))):new Promise((async(a,i)=>{e.current=!0,r({connectWallet:{onCompleteNavigateTo:m.EMBEDDED_WALLET_SIGN_REQUEST_SCREEN,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:n,confirmAndSign:()=>o(n),onSuccess:e=>a(e),onFailure:i,uiOptions:{}}}),t(m.EMBEDDED_WALLET_CONNECTING_SCREEN)})).finally((()=>{e.current=!1}))}}}})(),{user:u}=l(),{generateSiweMessageForSmartWallet:p,linkSmartWallet:y,noPromptOnSignature:g}=o();return r((()=>{(async()=>{if(n&&!u?.smartWallet&&s?.enabled)try{let e=await p({address:n.account.address,chainId:`eip155:${n.chain.id}`});g.current=!0;let t=await n.signMessage({message:e});await y({signature:t,message:e,smartWalletType:s.smartWalletType})}catch(e){console.error("Error creating smart wallet:",e)}finally{g.current=!1}})()}),[!!n,!!u?.smartWallet,!!s?.enabled]),e(D.Provider,{value:{client:u?.smartWallet&&n?c(n):void 0},children:a})};export{F as SmartWalletsProvider,_ as useSmartWallets};
